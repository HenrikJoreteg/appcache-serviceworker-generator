var fs = require('fs')
var path = require('path')
var glob = require('glob')
var extend = require('extend-object')

function Cache (spec) {
  if (!spec || !spec.version) throw new Error('Must provide a manifest version string')
  this.version = spec.version
  this._cache = spec.cache || {}
  this._network = spec.network || {}
  this._fallback = spec.fallback || {}
  if (spec.allowOtherPaths !== false) {
    this._add('network', '*')
    this.allowOtherPaths = true
  } else {
    this.allowOtherPaths = false
  }
}

Cache.prototype.cache = function (stuff) {
  this._add('cache', stuff)
}

Cache.prototype.network = function (stuff) {
  this._add('network', stuff)
}

Cache.prototype.fallback = function (stuff) {
  this._add('fallback', stuff)
}

Cache.prototype.cacheFolder = function (folderPath, globString) {
  folderPath = path.resolve(folderPath) + path.sep
  globString = folderPath + (globString || '*.*')
  var files = glob.sync(globString)
  files.forEach(function (file) {
    this.cache('/' + file.replace(folderPath, '').replace('\\', '/'))
  }, this)
}

Cache.prototype._add = function (type, stuff) {
  var res = {}
  type = '_' + type

  if (typeof stuff === 'string') {
    res[stuff] = true
  } else {
    res = stuff
  }

  extend(this[type], res)
}

// helper for adding everything in webpack assets object
Cache.prototype.cacheAllWebpackAssets = function (assets) {
  // tolerate getting a "stats" object too
  if (!Array.isArray(assets) && assets.assets) {
    assets = assets.assets
  }

  if (!Array.isArray(assets)) {
    throw new Error('cacheAllWebpackAssets must get either a whole webpack stats object or a stats.assets array.')
  }

  assets.forEach(function (asset) {
    this.cache('/' + asset.name)
  }, this)
}

Cache.prototype.toAppCache = function () {
  var out = ['CACHE MANIFEST', '# version: ' + this.version]

  ;['cache', 'network', 'fallback'].forEach(function (type) {
    var name = '_' + type
    var keys = Object.keys(this[name])
    if (keys.length) {
      out.push('', type.toUpperCase() + ':')
      out = out.concat(keys)
    }
  }, this)

  return out.join('\n')
}

Cache.prototype.toServiceWorker = function (opts) {
  var urls = Object.keys(this._cache)
  var fallbacks = {}
  var out = '// File programmatically generated by `appcache-serviceworker-generator` on npm' + '\n\n'

  out += fs.readFileSync(__dirname + '/polyfill.js', 'utf8') + '\n\n'
  out += fs.readFileSync(__dirname + '/sw-template.js', 'utf8')

  Object.keys(this._fallback).forEach(function (item) {
    var split = item.split(' ')
    fallbacks[split[0]] = split[1]
  }, this)

  out = out.replace('\'{{URLS}}\'', JSON.stringify(urls))
  out = out.replace('\'{{FALLBACKS}}\'', JSON.stringify(fallbacks))
  out = out.replace('\'{{ALLOW_NETWORK}}\'', JSON.stringify(this.allowOtherPaths))
  return out
}

module.exports = function (opts) {
  return new Cache(opts)
}
